; Minimal FORTH for blackhole_os
; How is this gonna work? No clue.
; Status stuff @ 0x0FF0
; Strings @ 0x1000
; System word space 0x2000-0x3FFF
; User word space 0x4000-0xAFFF
; Line space 0xB000-0xB7FF
; Token parsing space 0xB800-0xBFFF
; Compiled token space 0xC000-0xCFFF


; Step 0: Zero out memory

; Initialize HL to end of system words
set_h end_system_words
set_l end_system_words

; Set a label for a loop to zero memory until H == 0xD0
lbl step_0_zero_mem
set_dref 0x0
inc
set_a_h
cmp 0xD0
jnz step_0_zero_mem


; Step 1: Read user input
; Store at 0xB000, break at CR (0x0D) char
; Null-terminate
lbl step_1_read_input
; Print READY
set_h system_ready
set_l system_ready
rcl
inc
cmp 0x0
jez 3
out
jrel -5
set_acc 0x0D
out
sub 3
out
; Store line space addr into HL
set_h 0xB0
set_l 0x00

; Label for input loop
lbl step_1_read_input_loop
in ; Read one byte from io
cmp 0x0A
jez 2
cmp 0x0D ; Check if it's a newline (will break loop)
jez step_1_read_input_loop_break ; Break the loop
cmp 0x08 ; Check for backspace (they're special)
jnz 5 ; If not, jump past the next code
dec 
rcl ; Decrement and read the previous char
out
jrel step_1_read_input_loop
out
sto ; Store whatever's in A (read char or prev char if backspace)
inc ; And increment
jrel step_1_read_input_loop
lbl step_1_read_input_loop_break ; Break loop here
set_acc 0x0D
out
sub 3
out
set_dref 0x00 ; Null terminate string by writing to whatever HL was pointing to


; Step 2: Parse input into tokens
; Split by space (0x20)
; Write temp tokens into 0xB800
; Replace space with 0x00
lbl step_2_tokenize_input

; Set main HL to beginning of line space
set_h 0xB0
set_l 0x00

lbl step_2_start_new_token ; Set alt HL to point to the beginning of temp token space
ex_hl
set_h 0xB8
set_l 0x00
ex_hl

; Begin main loop
lbl step_2_tokenizer_loop
rcl ; Read a character from line space
inc 
cmp 0x20 ; If it's a space we're done with this token
jez step_2_token_parsed ; Jump to code to jump to token matcher with return set to this loop
cmp 0x00 ; If it's a null we're done with the line
jez step_2_line_parsed ; Jump to code to jump to token matcher with return set to step 4
ex_hl ; Switch to temp space
sto
inc ; Store and increment
ex_hl ; Back to line space
jrel step_2_tokenizer_loop

lbl step_2_token_parsed ; Jump here on end of token
ex_hl ; Temp space
set_dref 0x00 ; Denote end of token
ex_hl ; Line space

;set_a_l
;bak ; Set backup register to L
;set_a_h ; Set main A to H

;set_h system_line_space_backup
;set_l system_line_space_backup
;sto ; Store H in system_line_space_backup
;inc
;res
;sto ; Store L in system_line_space_backup + 1 
push_hl
set_h step_2_token_parsed_return
set_l step_2_token_parsed_return
push_hl
jrel step_3_match_tokens

lbl step_2_token_parsed_return ; Return addr
pop_hl
;set_h system_line_space_backup
;set_l system_line_space_backup
;rcl
;bak
;inc
;rcl
;set_l_a
;res
;set_h_a
jrel step_2_start_new_token

lbl step_2_line_parsed ; Jump here on end of line
ex_hl ; Temp space
set_dref 0x00 ; Denote end of token
ex_hl ; Line space
set_h step_4_run_comp
set_l step_4_run_comp
push_hl


; Step 3: Match tokens against system words
; Compare each character
; If both the word and token hit 0xFF and match along the way
; Write the 2-byte index of the word to a byte in compiled space (0xC000)
; Then goto step 2
; If token doesn't match, goto step 3.5
lbl step_3_match_tokens

set_h system_symbol_search_idx ; Zero out search idx
set_l system_symbol_search_idx
set_dref 0x0
inc
set_dref 0x0

; Set alt HL to point to system words
set_h system_words
set_l system_words

ex_hl ; Switch to main HL and set to point to temp space
lbl step_3_match_tokens_reset_temp_space ; label for when we fail a match
set_h 0xB8
set_l 0x00

; Search for next system word (denoted by a ':' 0x3A)
ex_hl ; word space
lbl step_3_find_next_word
rcl
inc
cmp 0x3B ; First we're looking for the closing ';' (0x3B)
jnz step_3_find_next_word
rcl
;out
cmp 0x3A ; If we found the ';', the next char should be a ':'
jez 5
set_h 0x40 ; Otherwise, check user space
set_l 0x00
rcl
cmp 0x3A
jez 4;15
; Check to see if it's a number
; Old: Throw an error
set_h step_3.5_conv_number;system_invalid_symbol
set_l step_3.5_conv_number;system_invalid_symbol
;rcl
;inc
;cmp 0x00
;jez 3
;out
;jrel -5
;set_acc 0x0D
;out
;sub 3
;out
;pop_hl
jmp
inc ; increment to skip the space after the ':'
inc
ex_hl ; temp space
; Begin main loop
lbl step_3_match_tokens_loop
ex_hl ; word space
rcl
inc
;out
bak ; Read char from word space into bak
ex_hl ; temp space
rcl ; Read char from temp space into acc
;out
inc

; Compare them
push_a ; backup temp space to be safe
sub_bak
;out
cmp 0x00 ; If we're 0x00 we matched
jez step_3_matched
; otherwise do things
pop_a
;cmp 0x00 ; check if temp char is null
;jez 4
;res ; check if word char is null
;cmp 0x00
;jnz step_3_match_tokens_loop

set_h system_symbol_search_idx ; Increment the search index
set_l system_symbol_search_idx
rcl
add 1
sto
cmp 0x00
jnz 5 
inc
rcl
add 1
sto
jrel step_3_match_tokens_reset_temp_space ; Otherwise, next token

lbl step_3_matched
pop_a ; check if temp char is null
cmp 0x00
jnz step_3_match_tokens_loop
set_h system_ok
set_l system_ok
rcl
inc
cmp 0x00
jez 3
out
jrel -5
set_acc 0x0D
out
sub 3
out
set_h system_compiled_space_ptr
set_l system_compiled_space_ptr
rcl
bak
add 2
sto
inc
cmp 0x00
jnz 5 
rcl
add 1
sto
sub 1
rcl
set_h_a
res
set_l_a
ex_hl
set_a_h
bak
set_a_l
ex_hl
sto
inc
res
sto
ex_hl
pop_hl
jmp

; Step 3.5: Convert token to number
; Convert each digit by subtracting 0x30
; If digits are in range, add them up
; If the token is a valid number, add 0xFF[NUMBER] to compiled space
lbl step_3.5_conv_number
pop_hl
ex_hl
set_h 0xB7
set_l 0xFF
set_dref 0xFF
inc
lbl step_3.5_conv_number_loop
rcl
cmp 0x0
jez add_everything_together
cmp 0x30
jlz step_3.5_conv_error
cmp 0x3A
jgz step_3.5_conv_error
sub 0x30
sto
inc
jrel step_3.5_conv_number_loop
lbl add_everything_together
dec
rcl
bak
cmp 0xFF
jez store_conversion
; 10s place
dec
rcl
cmp 0xFF
jez store_conversion
cmp 0x0
jez 8
push_a
res
add 10
bak
pop_a
sub 1
jrel -8
; 100s place
dec
rcl
cmp 0xFF
jez store_conversion
cmp 0x0
jez 8
push_a
res
add 100
bak
pop_a
sub 1
jrel -8
lbl step_3.5_conv_error
set_h system_invalid_symbol
set_l system_invalid_symbol
rcl
inc
cmp 0x0
jez 3
out
jrel -5
set_acc 0x0D
out
sub 3
out
ex_hl
jmp

lbl store_conversion
res
push_a
set_h system_ok
set_l system_ok
rcl
inc
cmp 0x00
jez 3
out
jrel -5
set_acc 0x0D
out
sub 3
out
set_h system_compiled_space_ptr
set_l system_compiled_space_ptr
rcl
bak
add 2
sto
inc
cmp 0x0
jnz 4 
rcl
add 1
sto
rcl
set_h_a
res
set_l_a
set_dref 0x00
inc
pop_a
sto
ex_hl
jmp

; Step 4: Run compiled space
; If in compiler mode then wait for run symbol
; Else if compiled space is closed (i.e. a word def with a matching : and ;, or is a standard line that's done)
; Run it by reading each byte, then jumping to the respective word, running that, and jumping back.
; Once done, jump to step 1
lbl step_4_run_comp
set_h system_compiled_space_ptr
set_l system_compiled_space_ptr
rcl
bak
set_dref 0x00
inc
rcl
set_dref 0xC0
set_h_a
res
set_l_a ; Recover compiled space ptr, set last section to 0xFFFF
set_dref 0xFF
inc
set_dref 0xFF
set_h system_run_ptr_bak
set_l system_run_ptr_bak
set_dref 0x00 ; compiled space
inc
set_dref 0xC0
ex_hl
set_h step_4_run_loop
set_l step_4_run_loop
lbl step_4_run_loop ; run loop
ex_hl
set_h system_run_ptr_bak
set_l system_run_ptr_bak
rcl
bak
inc
rcl
set_h_a
res
set_l_a
lbl step_4_run_loop_no_recovery
rcl
bak
inc
rcl
cmp 0xFF
jnz 4
res
cmp 0xFF
jez step_4_end_run_loop
res
cmp 0x0
jnz 5
rcl
push_a
inc
jrel step_4_run_loop_no_recovery
;out
push_a
rcl
;out
push_a
inc
set_a_h
bak
set_a_l
set_h system_run_ptr_bak
set_l system_run_ptr_bak
sto
inc
res
sto
pop_a
set_h_a
pop_a
set_l_a
jmp

lbl step_4_end_run_loop
set_h step_1_read_input
set_l step_1_read_input
jmp

; Reserved memory for backing up a couple values
org 0x07F0
lbl system_compiler_mode
word 0x0000
lbl system_line_space_backup
word 0x0000
lbl system_symbol_search_idx
word 0x0000
lbl system_compiled_space_ptr ; little-endian
word 0x00C0
lbl system_run_ptr_bak
word 0x0000
; system strings
; this gets doubled, starts at 0x1000
org 0x800
lbl system_ready
word 0x0D0A
str READY
lbl system_ok
str OK
lbl system_invalid_symbol
str ?SYM 
lbl system_syntax_error
str ?SYNTAX
lbl system_break
str ?BREAK
lbl debug_token
str ?TOKEN 
lbl system_crit_error
str ?CRIT

; system words
; starts at 0x2000
; 0x003B = delimiter
org 0x1000
lbl system_words
word 0x003B
str : +
pop_a
bak
pop_a
add_bak
push_a
ex_hl
jmp
word 0x003B
str : putc
pop_a
out
ex_hl
jmp
word 0x003B
str : getc
in
push_a
ex_hl
jmp
word 0x003B
str : -
pop_a
bak
pop_a
sub_bak
push_a
ex_hl
jmp
word 0x003B
str : dup
pop_a
push_a
push_a
ex_hl
jmp
word 0x003B
str : 1+
pop_a
add 1
push_a
ex_hl
jmp
word 0x003B
str : 1-
pop_a
sub 1
push_a
ex_hl
jmp
word 0x003B
lbl end_system_words