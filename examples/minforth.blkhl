; Minimal FORTH for blackhole_os
; How is this gonna work? No clue.
; Strings @ 0x1000
; System word space 0x2000-0x3FFF
; User word space 0x4000-0xAFFF
; Line space 0xB000-0xBFFF
; Token parsing space 0xC000-0xC0FF
; Compiled token space 0xC100-0xCFFF

; Step 1: Read user input
; Store at 0xB000, break at CR (0x0D) char
; Null-terminate

; Step 2: Parse input into tokens
; Split by space (0x20)
; Write temp tokens into 0xC000
; Replace space with 0xFF

; Step 3: Match tokens against system words
; Compare each character
; If both the word and token hit 0xFF and match along the way
; Write the 2-byte index of the word to a byte in compiled space (0xC100)
; Then goto step 2
; If token doesn't match, goto step 3.5

; Step 3.5: Convert token to number
; Convert each digit by subtracting 0x30
; If digits are in range, add them up
; If the token is a valid number, add 0xFF[NUMBER] to compiled space

; Step 4: Run compiled space
; If in compiler mode then wait for run symbol
; Else if compiled space is closed (i.e. a word def with a matching : and ;, or is a standard line that's done)
; Run it by reading each byte, then jumping to the respective word, running that, and jumping back.
; Once done, jump to step 1

; system strings
; this gets doubled, starts at 0x1000
org 0x800
lbl system_ok
str OK
lbl system_invalid_symbol
str ?SYM 
lbl system_syntax_error
str ?SYNTAX
lbl system_break
str ?BREAK
lbl debug_token
str ?TOKEN 
lbl system_crit_error
str ?CRIT

; system words
; starts at 0x2000
; FF3B = delimiter
org 0x1000
lbl system_words
str : +
pop_a
cmp 0x0
jez 9 
bak
pop_a
add 1
push_a
res
sub 1
bak
jnz -6
jmp
word 0xFF3B
str : putc
pop_a
out
jmp
word 0xFF3B
str : getc
in
push_a
jmp
word 0xFF3B
str : -
pop_a
cmp 0x0
jez 9 
bak
pop_a
sub 1
push_a
res
sub 1
bak
jnz -6
jmp
word 0xFF3B